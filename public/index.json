[{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 **JSX(JavaScript XML)**입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 **\u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo;**라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 **\u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo;**로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 **\u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo;**라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 **JSX(JavaScript XML)**입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 **\u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo;**라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 **\u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo;**로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 **\u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo;**라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 **\u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo;**로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 **\u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo;**라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 **\u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo;**라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) **규칙 3. class 대신 className ** 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 **중괄호 { }**를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 열어주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n[이미지 - 스타일이 적용된 To-Do 앱 초기 화면] (설명: 깔끔한 흰색 카드 형태의 UI에 \u0026ldquo;Smart To-Do\u0026rdquo; 제목과 날짜, 그리고 입력창과 보라색 버튼이 배치된 모습)\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 **하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;)**로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. **class 대신 className**, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, **닫는 태그(/\u0026gt;)**는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 **중괄호 { }** 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 중괄호 { } 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 **레고 블록처럼 쪼개는 기술, 컴포넌트(Component)**에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 중괄호 { } 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 레고 블록처럼 쪼개는 기술, 컴포넌트(Component) 에 대해 배워보겠습니다.\n다음 포스팅: 👉 [React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 중괄호 { } 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 레고 블록처럼 쪼개는 기술, 컴포넌트(Component) 에 대해 배워보겠습니다.\n기대해 주세요! 댓글과 좋아요는 큰 힘이 됩니다. Qooing이었습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 중괄호 { } 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 레고 블록처럼 쪼개는 기술, 컴포넌트(Component) 에 대해 배워보겠습니다.\n기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 중괄호 { } 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 레고 블록처럼 쪼개는 기술, 컴포넌트(Component) 에 대해 배워보겠습니다.\n기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"}]