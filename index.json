[{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간까지 우리는 컴포넌트를 조립해서 그럴듯한 \u0026lsquo;Smart To-Do Planner\u0026rsquo;의 껍데기를 만들었습니다. 하지만 지금은 버튼을 아무리 광클해도 반응이 없는 \u0026lsquo;식물인간\u0026rsquo; 상태입니다.\n오늘 우리는 이 앱에 두 가지 핵심 능력을 부여할 것입니다.\nEvent (이벤트): 사용자의 행동(클릭)을 감지하는 귀 👂 State (상태): 화면의 데이터(입력값)를 기억하고 갱신하는 뇌 🧠 이 두 가지는 리액트가 살아 움직이게 만드는 가장 기초적이면서도 필수적인 엔진입니다. 순서대로 하나씩 정복해 봅시다!\n1. 리액트의 귀: 이벤트(Event) 개념 우리가 웹 서핑을 할 때 마우스를 클릭하거나 키보드를 치는 모든 행위를 \u0026lsquo;이벤트(Event)\u0026rsquo; 라고 합니다. 리액트가 이벤트를 처리하는 방식은 기존 HTML과 아주 비슷하지만, 결정적인 차이점 2가지가 있습니다.\n차이점 1. 소문자 말고 CamelCase HTML에서는 onclick이라고 썼지만, 리액트(JSX)에서는 자바스크립트 문법을 따르기 때문에 낙타 등처럼 중간 글자를 대문자로 써야 합니다.\nonclick (X) 👉 onClick (O) onchange (X) 👉 onChange (O) 차이점 2. 함수 \u0026lsquo;호출\u0026rsquo;이 아니라 \u0026lsquo;이름\u0026rsquo;만! 초보자들이 가장 많이 내는 에러 1위입니다. 🚨\n1 2 3 4 5 // ❌ 틀린 예시: 괄호()를 붙이면, 코드가 읽히자마자 바로 실행돼버립니다. \u0026lt;button onClick={handleClick()}\u0026gt;클릭\u0026lt;/button\u0026gt; // ⭕️ 맞는 예시: \u0026#34;클릭되면 이 함수를 실행해줘\u0026#34;라고 이름만 넘겨야 합니다. \u0026lt;button onClick={handleClick}\u0026gt;클릭\u0026lt;/button\u0026gt; 2. 실습 1: 버튼 클릭 감지하기 자, 이론은 여기까지! 바로 코드로 확인해 봅시다. src/components/TodoInput.jsx 파일을 열어서 버튼을 누르면 알림창이 뜨게 만들어보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // src/components/TodoInput.jsx function TodoInput() { // 1. 버튼이 클릭되면 실행될 함수를 만듭니다. const handleClick = () =\u0026gt; { alert(\u0026#34;버튼이 클릭되었습니다!\u0026#34;); }; return ( \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; {/* 2. 버튼에 onClick 이벤트를 연결합니다. (괄호 없이 이름만!) */} \u0026lt;button className=\u0026#34;add-btn\u0026#34; onClick={handleClick}\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default TodoInput; 저장하고 브라우저에서 \u0026lsquo;추가\u0026rsquo; 버튼을 눌러보세요. 알림창이 뜬다면 리액트의 \u0026lsquo;귀\u0026rsquo;가 열린 것입니다! 🎉\n3. 리액트의 뇌: State(상태) 개념 (매우 중요 ⭐️) 이벤트를 감지했다면, 이제 화면을 바꿔야겠죠? 여기서 State가 등장합니다.\n(1) State란 무엇인가요? State는 우리말로 \u0026lsquo;상태\u0026rsquo; 입니다. 리액트에서 State는 \u0026ldquo;컴포넌트의 현재 상황을 보여주는 정보(데이터)\u0026rdquo; 를 뜻합니다.\n쉽게 예를 들어볼까요?\n전등 스위치: [켜짐 / 꺼짐] 이라는 2가지 State를 가집니다. 카카오톡: [읽지 않음 1 / 읽음] 이라는 State를 가집니다. (2) 왜 일반 변수(let)는 안 되나요? \u0026ldquo;데이터라면 그냥 let name = \u0026quot;철수\u0026quot; 처럼 변수에 담아도 되잖아요?\u0026rdquo;\n여기서 리액트의 독특한 성격이 나옵니다. 리액트는 \u0026lsquo;게으른 화가\u0026rsquo; 입니다.\n일반 변수(let) 변경: 메모리 상의 값은 바뀝니다. 하지만 리액트는 이걸 쳐다보지도 않습니다. 리액트: \u0026ldquo;변수가 바뀌었네? 근데 나보고 어쩌라고? 난 다시 그리기 귀찮아.\u0026rdquo; (화면 갱신 X)\nState 변경: State는 리액트에게 보내는 강력한 신호입니다. 리액트: \u0026ldquo;앗! State가 바뀌었다! 주인님이 화면을 다시 그리라고 하신다! (Re-render)\u0026rdquo; (화면 갱신 O)\n(3) 사용법: useState 훅(Hook) 해부하기 리액트에서 State를 만들기 위해서는 useState 라는 특별한 함수(Hook)를 써야 합니다. 생김새가 좀 특이하니 자세히 뜯어봅시다.\n1 2 3 4 import { useState } from \u0026#39;react\u0026#39;; // 1. 도구 꺼내기 // 2. 사용하기 const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;); 이 한 줄에는 3가지 비밀이 숨어 있습니다.\nuseState(\u0026quot;\u0026quot;): \u0026ldquo;리액트야, 초기값이 빈 문자열(\u0026quot;\u0026quot;)인 상태 주머니 하나 만들어줘.\u0026rdquo; inputValue (첫 번째 변수): 현재 상태 값이 들어있습니다. 우리가 화면에 보여줄 때 사용합니다. setInputValue (두 번째 변수): 상태를 바꿀 수 있는 유일한 리모컨(함수) 입니다. inputValue = \u0026quot;안녕\u0026quot; 처럼 직접 바꾸면 안 됩니다! (리액트가 모름) setInputValue(\u0026quot;안녕\u0026quot;) 처럼 리모컨을 눌러야 리액트가 화면을 고칩니다. 참고: const [a, b] = ... 문법은 자바스크립트의 \u0026lsquo;구조 분해 할당\u0026rsquo; 입니다. 리액트가 주는 선물 상자(배열)를 열어서 첫 번째는 a에, 두 번째는 b에 담는다는 뜻입니다. 구조 분해 할당(Destructuring) 더 알아보기\n4. 실습 2: 입력창(Input) 제어하기 이제 우리가 배운 useState를 사용해, 입력창에 쓰는 글자를 리액트가 실시간으로 기억하도록 만들어봅시다. TodoInput.jsx를 다시 수정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // src/components/TodoInput.jsx // 1. useState 도구를 불러옵니다. import { useState } from \u0026#39;react\u0026#39;; function TodoInput() { // 2. State 선언: [현재값, 바꾸는함수] const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const handleClick = () =\u0026gt; { // 3. 버튼을 누르면 현재 State 값을 알림창으로 띄웁니다. alert(inputValue); }; return ( \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하세요\u0026#34; // 4. [중요] input의 주인은 이제 리액트(State)입니다. // 화면에 보여지는 값은 무조건 State를 따라갑니다. value={inputValue} // 5. [중요] 타이핑(Change)할 때마다 리모컨(setInputValue)을 누릅니다. // 이게 없으면 타이핑이 안 먹힙니다! (State가 안 바뀌면 화면도 안 바뀌니까요) onChange={(event) =\u0026gt; setInputValue(event.target.value)} /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34; onClick={handleClick}\u0026gt;추가\u0026lt;/button\u0026gt; {/* 6. 내가 쓰는 글자가 실시간으로 보이나요? */} \u0026lt;p\u0026gt;실시간 입력 중: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default TodoInput; 코드가 어떻게 동작하나요? 사용자가 키보드로 \u0026lsquo;A\u0026rsquo;를 칩니다. (onChange 발동) setInputValue('A')가 실행되어 리액트에게 알립니다. 리액트가 \u0026ldquo;State가 바뀌었네? 다시 그려!\u0026rdquo; 하고 깨어납니다. 화면의 \u0026lt;input\u0026gt;과 \u0026lt;p\u0026gt; 태그를 \u0026lsquo;A\u0026rsquo;가 들어간 상태로 다시 그립니다. 저장 후 브라우저에서 타이핑해 보세요. \u0026lt;p\u0026gt; 태그의 글자가 실시간으로 바뀌나요? 그렇다면 리액트의 \u0026lsquo;뇌\u0026rsquo;와 \u0026lsquo;귀\u0026rsquo;가 모두 정상 작동하는 것입니다!\n🚀 마치며 오늘 우리는 죽어있던 앱에 생명(State) 과 청력(Event) 을 선물했습니다.\n오늘의 핵심 요약:\nEvent: onClick처럼 CamelCase를 쓰며, 함수 이름만 전달한다. State: 리액트가 화면을 다시 그리게 만드는 유일한 트리거다. useState: [현재값, 변경함수]를 반환하며, 반드시 변경함수(set...)로 값을 바꿔야 한다. 이제 입력한 값을 저장하는 것까지 성공했습니다! 하지만 아직은 알림창만 뜰 뿐, 실제로 할 일 목록(List) 에는 추가되지 않죠?\n다음 시간에는 이 데이터를 부모 컴포넌트(App)에게 전달하고, 진짜 배열에 추가하는 \u0026ldquo;데이터 흐름의 마법(Props Drilling)\u0026rdquo; 을 배워보겠습니다.\n","permalink":"https://qooing.github.io/posts/react/react-tutorial-05/","summary":"\u003cp\u003e\u003cimg alt=\"React State\" loading=\"lazy\" src=\"/images/react/state.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간까지 우리는 컴포넌트를 조립해서 그럴듯한 \u0026lsquo;Smart To-Do Planner\u0026rsquo;의 껍데기를 만들었습니다. 하지만 지금은 버튼을 아무리 광클해도 반응이 없는 \u0026lsquo;식물인간\u0026rsquo; 상태입니다.\u003c/p\u003e\n\u003cp\u003e오늘 우리는 이 앱에 두 가지 핵심 능력을 부여할 것입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eEvent (이벤트):\u003c/strong\u003e 사용자의 행동(클릭)을 감지하는 귀 👂\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eState (상태):\u003c/strong\u003e 화면의 데이터(입력값)를 기억하고 갱신하는 뇌 🧠\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 두 가지는 리액트가 살아 움직이게 만드는 가장 기초적이면서도 필수적인 엔진입니다. 순서대로 하나씩 정복해 봅시다!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-리액트의-귀-이벤트event-개념\"\u003e1. 리액트의 귀: 이벤트(Event) 개념\u003c/h2\u003e\n\u003cp\u003e우리가 웹 서핑을 할 때 마우스를 클릭하거나 키보드를 치는 모든 행위를 \u003cstrong\u003e\u0026lsquo;이벤트(Event)\u0026rsquo;\u003c/strong\u003e 라고 합니다. 리액트가 이벤트를 처리하는 방식은 기존 HTML과 아주 비슷하지만, \u003cstrong\u003e결정적인 차이점 2가지\u003c/strong\u003e가 있습니다.\u003c/p\u003e","title":"[React 정복기 #05] 죽어있는 앱에 생명을! Event와 State 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 JSX 문법을 배워서 그럴듯한 \u0026lsquo;Smart To-Do Planner\u0026rsquo;의 화면을 만들었습니다. 그런데 지금 App.jsx 파일을 보면 어떤가요? 헤더, 입력창, 리스트가 한 파일에 뒤섞여 있죠?\n\u0026ldquo;음\u0026hellip; 코드가 100줄, 1000줄 넘어가면 나중에 어떻게 찾지?\u0026rdquo; 😱\n그래서 리액트 개발자들은 화면을 \u0026lsquo;컴포넌트(Component)\u0026rsquo; 라는 작은 부품으로 쪼개서 관리합니다. 오늘은 이 부품들을 만들고, 부품끼리 대화하는 방법인 Props에 대해 알아보겠습니다.\n1. 컴포넌트(Component): 레고 블록 만들기 컴포넌트는 거창한 게 아닙니다. 리액트에서는 \u0026ldquo;JSX를 반환하는 함수\u0026rdquo; 를 컴포넌트라고 부릅니다.\n지켜야 할 규칙은 딱 하나! 함수 이름의 첫 글자는 무조건 대문자여야 합니다. header (X) 👉 HTML 태그로 착각함 Header (O) 👉 리액트 컴포넌트로 인식함 2. 실습: 파일 쪼개기 (Refactoring) 자, 이제 App.jsx에 뭉쳐있는 코드들을 세 개의 파일로 분리해 보겠습니다. 먼저 src 폴더 안에 components라는 폴더를 하나 만들어주세요.\nStep 1. Header 컴포넌트 분리 src/components/Header.jsx 파일을 만들고 아래 코드를 붙여넣으세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // src/components/Header.jsx function Header() { const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; ); } export default Header; // 다른 파일에서 쓸 수 있게 내보내기 Step 2. TodoInput 컴포넌트 분리 src/components/TodoInput.jsx 파일을 만듭니다.\n1 2 3 4 5 6 7 8 9 10 11 12 // src/components/TodoInput.jsx function TodoInput() { return ( \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default TodoInput; Step 3. TodoList 컴포넌트 분리 src/components/TodoList.jsx 파일을 만듭니다.\n1 2 3 4 5 6 7 8 9 10 11 // src/components/TodoList.jsx function TodoList() { return ( \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default TodoList; 3. 조립하기: App.jsx 다이어트 이제 대망의 조립 시간입니다! 뚱뚱했던 App.jsx의 내용을 싹 지우고, 방금 만든 부품들을 가져와서 조립해 봅시다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // src/App.jsx import \u0026#39;./App.css\u0026#39; import Header from \u0026#39;./components/Header\u0026#39; import TodoInput from \u0026#39;./components/TodoInput\u0026#39; import TodoList from \u0026#39;./components/TodoList\u0026#39; function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;TodoInput /\u0026gt; \u0026lt;TodoList /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 어떤가요? 코드가 믿을 수 없을 정도로 깔끔해졌죠? 나중에 \u0026ldquo;입력창 디자인을 바꾸고 싶다\u0026rdquo; 하면 App.jsx를 뒤질 필요 없이 TodoInput.jsx만 찾아가면 됩니다. 이것이 바로 유지보수의 혁명입니다.\n4. Props: 부모가 자식에게 주는 선물 🎁 여기서 한 가지 아쉬운 점이 있습니다. Header 컴포넌트를 보면 \u0026ldquo;Smart To-Do\u0026quot;라는 제목이 고정되어 있죠. 만약 다른 페이지에서 \u0026ldquo;My Diary\u0026quot;라는 제목으로 똑같은 디자인을 쓰고 싶다면?\n이럴 때 사용하는 것이 바로 Props(Properties) 입니다. 부모(App)가 자식(Header)에게 데이터를 전달하는 방법이죠.\n실습: 제목을 맘대로 바꾸기 1. 부모(App.jsx)에서 데이터 던져주기 \u0026lt;Header /\u0026gt;를 부를 때 title이라는 이름으로 값을 넘겨줍니다.\n1 2 3 4 // src/App.jsx 수정 // ... \u0026lt;Header title=\u0026#34;Smart To-Do Planner\u0026#34; /\u0026gt; // ... 2. 자식(Header.jsx)에서 데이터 받기 함수의 파라미터로 props를 받아서 사용합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // src/components/Header.jsx 수정 // props라는 매개변수를 받습니다. function Header(props) { // ... 날짜 코드는 생략 ... return ( \u0026lt;header\u0026gt; {/* props.title로 꺼내 씁니다 */} \u0026lt;h1\u0026gt;{props.title}\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; ); } 이제 App.jsx에서 title=\u0026quot;나만의 일기장\u0026quot;으로 바꾸면 화면의 제목도 즉시 바뀝니다. 하나의 컴포넌트를 여러 용도로 재사용할 수 있게 된 것이죠!\n💡 Qooing의 꿀팁: 구조 분해 할당 props.title 이라고 매번 치기 귀찮죠? 현업에서는 이렇게 더 많이 씁니다.\n1 2 3 function Header({ title }) { // props 대신 { title } 바로 받기 return \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt;; } 구조 분해 할당(Destructuring) 더 알아보기\n🚀 마치며 오늘 우리는 리액트 개발의 핵심인 구조화(Structure) 를 배웠습니다.\n오늘의 핵심 3줄 요약:\n컴포넌트는 UI를 독립적인 파일로 쪼갠 것이다. (첫 글자는 대문자!) import / export 를 통해 부품을 조립한다. Props를 사용하면 부모에서 자식으로 데이터를 전달해 재사용성을 높일 수 있다. 하지만 아직 우리 앱은 껍데기뿐입니다. 버튼을 눌러도 아무 반응이 없죠? 다음 시간에는 드디어 버튼을 클릭하면 실제로 할 일이 추가되는 기능(Event \u0026amp; State) 을 구현해 보겠습니다. 진짜 움직이는 앱이 되는 순간이죠!\n기대해 주세요!\n","permalink":"https://qooing.github.io/posts/react/react-tutorial-04/","summary":"\u003cp\u003e\u003cimg alt=\"React Component\" loading=\"lazy\" src=\"/images/react/component.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 JSX 문법을 배워서 그럴듯한 \u0026lsquo;Smart To-Do Planner\u0026rsquo;의 화면을 만들었습니다. 그런데 지금 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면 어떤가요? 헤더, 입력창, 리스트가 한 파일에 뒤섞여 있죠?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;음\u0026hellip; 코드가 100줄, 1000줄 넘어가면 나중에 어떻게 찾지?\u0026rdquo;\u003c/em\u003e 😱\u003c/p\u003e\n\u003cp\u003e그래서 리액트 개발자들은 화면을 \u003cstrong\u003e\u0026lsquo;컴포넌트(Component)\u0026rsquo;\u003c/strong\u003e 라는 작은 부품으로 쪼개서 관리합니다. 오늘은 이 부품들을 만들고, 부품끼리 대화하는 방법인 \u003cstrong\u003eProps\u003c/strong\u003e에 대해 알아보겠습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-컴포넌트component-레고-블록-만들기\"\u003e1. 컴포넌트(Component): 레고 블록 만들기\u003c/h2\u003e\n\u003cp\u003e컴포넌트는 거창한 게 아닙니다. 리액트에서는 \u003cstrong\u003e\u0026ldquo;JSX를 반환하는 함수\u0026rdquo;\u003c/strong\u003e 를 컴포넌트라고 부릅니다.\u003c/p\u003e","title":"[React 정복기 #04] UI를 조각내는 기술, 컴포넌트 분리하기 (feat. Props)"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다. 그런데 App.jsx 파일을 보면서 혹시 이런 생각 안 드셨나요?\n\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\n이 이상한 문법의 정체는 바로 JSX(JavaScript XML) 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\n오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, 절대 어기면 안 되는 JSX의 핵심 규칙 4가지를 파헤쳐 보겠습니다.\n1. JSX: 브라우저는 이걸 모릅니다 (feat. Transpiling) 사실 웹 브라우저(Chrome, Safari 등)는 JSX를 전혀 이해하지 못합니다. 브라우저는 오직 순수한 자바스크립트만 읽을 수 있죠.\n그럼 어떻게 화면이 나오는 걸까요? 우리가 구축한 Vite 환경 내부에는 \u0026lsquo;트랜스파일러(Transpiler)\u0026rsquo; 라는 번역기가 숨어 있습니다. (개발 모드에서는 주로 esbuild 라는 친구가 이 일을 합니다.)\n우리가 편하게 HTML처럼 작성하면, 이 번역기가 순식간에 \u0026ldquo;브라우저가 이해할 수 있는 자바스크립트\u0026rdquo; 로 변환해서 전달해 주는 것이죠. 그래서 우리는 이걸 \u0026ldquo;Syntactic Sugar (문법적 설탕)\u0026rdquo; 라고 부릅니다. 개발자 편하라고 뿌려준 달콤한 문법이라는 뜻이죠. 🍬\n2. 절대 어기면 안 되는 4가지 규칙 (매우 중요! ⭐️) JSX는 HTML과 비슷하게 생겼지만, 엄연히 자바스크립트입니다. 그래서 까다로운 규칙들이 몇 가지 있습니다.\n규칙 1. 반드시 하나의 부모 태그로 감싸라! 리액트 컴포넌트는 무조건 하나의 덩어리를 반환(return)해야 합니다. 자바스크립트 함수는 값을 하나만 반환할 수 있기 때문입니다.\n❌ 틀린 예시:\n1 2 3 4 5 6 function App() { return ( \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; // 덩어리 1 \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; // 덩어리 2 (에러 발생! 🚨) ); } ⭕️ 맞는 예시 (Fragment 사용): 불필요한 \u0026lt;div\u0026gt;를 만들기 싫다면, Fragment(\u0026lt;\u0026gt; ... \u0026lt;/\u0026gt;) 문법을 사용하세요. HTML에는 남지 않고 리액트에게 \u0026ldquo;이거 한 덩어리야\u0026quot;라고 알려주는 역할만 합니다.\n1 2 3 4 5 6 7 8 function App() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;제목\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;내용\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } 규칙 2. 닫는 태그는 필수! HTML에서는 \u0026lt;input\u0026gt;이나 \u0026lt;br\u0026gt; 태그를 닫지 않아도 대충 알아서 넘어갔습니다. 하지만 JSX는 짤없습니다. 무조건 닫아야 합니다.\n\u0026lt;input\u0026gt; (X) 👉 \u0026lt;input /\u0026gt; (O) \u0026lt;br\u0026gt; (X) 👉 \u0026lt;br /\u0026gt; (O) \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; (X) 👉 \u0026lt;img src=\u0026quot;...\u0026quot; /\u0026gt; (O) 규칙 3. class 대신 className 이게 가장 많이 하는 실수입니다! 자바스크립트에는 이미 class(객체 지향 문법)라는 예약어가 존재합니다. 그래서 HTML의 클래스를 지정할 때는 이름을 살짝 바꿔야 합니다.\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; (X) 👉 \u0026lt;div className=\u0026quot;box\u0026quot;\u0026gt; (O) 규칙 4. 자바스크립트 변수는 { } 안에! HTML 중간에 자바스크립트 변수나 함수를 넣고 싶다면 중괄호 { } 를 사용해 주세요. 이곳은 자바스크립트가 활동할 수 있는 통로입니다.\n1 2 const name = \u0026#34;Qooing\u0026#34;; return \u0026lt;h1\u0026gt;안녕, {name}!\u0026lt;/h1\u0026gt;; // 화면에 \u0026#34;안녕, Qooing!\u0026#34; 출력 3. 실습: Smart To-Do Planner 골격 잡기 자, 이제 배운 규칙들을 활용해 우리 앱의 기본 구조를 잡아볼까요? src/App.jsx를 열고 아래 코드를 작성해 보세요. (기존 내용은 다 지우셔도 됩니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // src/App.jsx import \u0026#39;./App.css\u0026#39; function App() { // 자바스크립트 영역: 날짜를 가져옵니다. const today = new Date().toLocaleDateString(\u0026#39;ko-KR\u0026#39;, { year: \u0026#39;numeric\u0026#39;, month: \u0026#39;long\u0026#39;, day: \u0026#39;numeric\u0026#39; }); return ( // JSX 영역 \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더 영역 */} \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Smart To-Do\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;date-text\u0026#34;\u0026gt;오늘은 {today} 입니다.\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; {/* 2. 입력 영역 */} \u0026lt;div className=\u0026#34;input-box\u0026#34;\u0026gt; {/* 규칙: 닫는 태그 필수! */} \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;할 일을 입력하고 엔터를 치세요\u0026#34; /\u0026gt; \u0026lt;button className=\u0026#34;add-btn\u0026#34;\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 3. 리스트 영역 (나중에 채울 예정) */} \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;p\u0026gt;아직 등록된 할 일이 없습니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 💡 코드 뜯어보기 {today}: 자바스크립트로 구한 오늘 날짜 변수를 중괄호를 사용해 HTML 사이에 쏙 넣었습니다. className=\u0026quot;date-text\u0026quot;: class 대신 className을 사용했습니다. \u0026lt;input ... /\u0026gt;: 끝에 /를 붙여서 태그를 확실하게 닫아주었습니다. 4. (보너스) 스타일링 살짝 입히기 🎨 화면이 너무 밋밋하죠? src/App.css 파일을 열어서 내용을 싹 지우고, 아래 코드를 복사해서 붙여넣어 보세요. (디자인은 거들 뿐이니 가볍게만 적용합니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* src/App.css */ .app-container { max-width: 500px; margin: 50px auto; padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); text-align: center; background-color: #fff; } h1 { color: #333; margin-bottom: 5px; } .date-text { color: #888; font-size: 0.9rem; margin-bottom: 30px; } .input-box { display: flex; gap: 10px; margin-bottom: 20px; } input { flex: 1; padding: 10px; border-radius: 5px; border: 1px solid #ddd; } .add-btn { padding: 10px 20px; background-color: #646cff; color: white; border: none; border-radius: 5px; cursor: pointer; } .add-btn:hover { background-color: #535bf2; } 저장하고 브라우저를 확인해 보세요. 제법 그럴듯한 앱의 모양이 갖춰졌죠?\n🚀 마치며 오늘 우리는 리액트의 가장 기본이 되는 언어, JSX를 정복했습니다.\n오늘의 핵심 3줄 요약:\nJSX는 하나의 태그(\u0026lt;\u0026gt;...\u0026lt;/\u0026gt;) 로 감싸야 한다. class 대신 className, 닫는 태그(/\u0026gt;) 는 필수다. 자바스크립트 변수는 중괄호 { } 안에 넣는다. 지금은 App.jsx 파일 하나에 제목, 입력창, 리스트가 다 들어있습니다. 코드가 길어지면 관리하기 힘들겠죠? 다음 시간에는 이 덩어리를 레고 블록처럼 쪼개는 기술, 컴포넌트(Component) 에 대해 배워보겠습니다.\n기대해 주세요!\n","permalink":"https://qooing.github.io/posts/react/react-tutorial-03/","summary":"\u003cp\u003e\u003cimg alt=\"겉은 HTML, 속은 JS\" loading=\"lazy\" src=\"/images/react/html_js.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에 우리는 Vite로 개발 환경을 구축하고 서버를 띄우는 데 성공했습니다.\n그런데 \u003ccode\u003eApp.jsx\u003c/code\u003e 파일을 보면서 혹시 이런 생각 안 드셨나요?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u0026ldquo;분명 자바스크립트 파일(.jsx)인데, 왜 안에 HTML 태그가 들어있지? 이거 에러 안 나나?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 이상한 문법의 정체는 바로 \u003cstrong\u003eJSX(JavaScript XML)\u003c/strong\u003e 입니다. 리액트 개발의 90%는 이 JSX를 얼마나 잘 다루느냐에 달려 있다고 해도 과언이 아닙니다.\u003c/p\u003e\n\u003cp\u003e오늘은 리액트가 뱉어내는 빨간 에러 줄에 겁먹지 않도록, \u003cstrong\u003e절대 어기면 안 되는 JSX의 핵심 규칙 4가지\u003c/strong\u003e를 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #03] HTML인 척하는 자바스크립트? JSX 문법 완벽 가이드"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"https://qooing.github.io/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"https://qooing.github.io/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"안녕하세요! 이전 포스팅에서는 JavaScript의 구조 분해 할당(Destructuring) 시 변수 이름을 변경하는 방법에 대해 알아보았습니다. 코드를 깔끔하게 만들어주는 유용한 문법이지만, 이를 TypeScript(타입스크립트) 환경으로 가져오면 많은 개발자들이 헷갈려 하는 구간이 생깁니다.\n바로 자바스크립트의 \u0026lsquo;이름 변경\u0026rsquo; 문법인 콜론(:)과 타입스크립트의 \u0026lsquo;타입 지정\u0026rsquo; 문법인 콜론(:)이 똑같이 생겼기 때문인데요.\n오늘은 TypeScript 환경에서 에러 없이 객체의 구조 분해 할당, 이름 변경, 그리고 타입 지정까지 한 번에 처리하는 올바른 방법을 정리해 보겠습니다.\n🚨 흔히 하는 실수: 문법의 충돌 API 응답으로 스네이크 케이스(user_id) 데이터를 받아 카멜 케이스(userId)로 변환하면서, 동시에 number라는 타입을 지정하고 싶다고 가정해 봅시다.\n처음 TypeScript를 접하면 직관적으로 아래와 같이 코드를 작성하기 쉽습니다.\n1 2 3 4 5 6 7 const apiResponse = { user_id: 101, user_name: \u0026#39;김개발\u0026#39; }; // ❌ 잘못된 예: 에러 발생! const { user_id: userId: number, user_name: userName: string } = apiResponse; 하지만 이 코드는 에러를 뱉어냅니다. TypeScript 파서는 userId: number 부분을 \u0026lsquo;userId라는 이름을 number라는 이름의 변수로 한 번 더 바꾸겠다\u0026rsquo; 는 의미로 해석해버리기 때문입니다. 타입스크립트는 구조 분해 할당 내부의 콜론(:)을 오직 \u0026lsquo;이름 변경(Renaming)\u0026lsquo;으로만 취급합니다.\n✅ 올바른 해결책: 값의 추출과 타입 선언의 분리 TypeScript에서 이 문제를 해결하려면 할당하는 변수 구조(중괄호) 와 타입 선언 구조 를 명확히 분리해야 합니다. 전체 객체의 모양을 구조 분해 할당 괄호 뒤에 따로 명시해 주는 것이 핵심입니다.\n방법 1. 인라인(Inline)으로 타입 지정하기 간단한 객체라면 구조 분해 할당 직후에 곧바로 타입을 명시할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 const { user_id: userId, user_name: userName }: { user_id: number; user_name: string; } = apiResponse; console.log(userId); // 101 (number 타입으로 정상 추론됨) console.log(userName); // \u0026#39;김개발\u0026#39; (string 타입으로 정상 추론됨) 하지만 속성이 많아지면 코드가 가로로 길어지고 가독성이 떨어지는 단점이 있습니다.\n방법 2. Interface나 Type Alias 사용하기 (✨ 실무 권장) 실무에서는 가독성과 재사용성을 위해 interface나 type을 미리 정의해두고 사용하는 방식을 가장 많이 활용합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 1. 타입을 먼저 정의합니다. interface UserResponse { user_id: number; user_name: string; } const apiResponse: UserResponse = { user_id: 101, user_name: \u0026#39;김개발\u0026#39; }; // 2. 정의한 타입을 할당문에 지정합니다. const { user_id: userId, user_name: userName }: UserResponse = apiResponse; 이렇게 하면 코드가 훨씬 깔끔해지고, UserResponse라는 타입을 다른 곳에서도 재사용할 수 있어 유지보수에 유리합니다.\n💡 보너스: 기본값(Default Value)까지 추가한다면? 이름 변경, 타입 지정에 이어 데이터가 없을 때를 대비한 기본값까지 추가해야 한다면 어떻게 될까요? 할당 연산자(=)를 사용해 아래와 같이 작성할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface UserSettings { theme?: string; language?: string; } const settings: UserSettings = { theme: \u0026#39;dark\u0026#39; }; // theme -\u0026gt; currentTheme 변경 (기본값 \u0026#39;light\u0026#39;) // language -\u0026gt; currentLang 변경 (기본값 \u0026#39;ko\u0026#39;) const { theme: currentTheme = \u0026#39;light\u0026#39;, language: currentLang = \u0026#39;ko\u0026#39; }: UserSettings = settings; console.log(currentTheme); // \u0026#39;dark\u0026#39; (기존 값 유지) console.log(currentLang); // \u0026#39;ko\u0026#39; (값이 없으므로 기본값 할당) 마치며 TypeScript에서 구조 분해 할당을 다룰 때 가장 중요한 규칙은 하나입니다. \u0026ldquo;구조 분해 할당 안에서의 :은 이름 변경이고, 중괄호 {} 밖에서의 :은 타입 지정이다.\u0026rdquo; 이 규칙만 기억하신다면, 아무리 복잡한 객체가 들어오더라도 자유자재로 이름을 바꾸고 안전하게 타입을 입혀 사용하실 수 있을 것입니다!\n","permalink":"https://qooing.github.io/posts/javascript/destructuring_typescript_renaming/","summary":"\u003cp\u003e안녕하세요! 이전 포스팅에서는 JavaScript의 구조 분해 할당(Destructuring) 시 변수 이름을 변경하는 방법에 대해 알아보았습니다. 코드를 깔끔하게 만들어주는 유용한 문법이지만, 이를 \u003cstrong\u003eTypeScript(타입스크립트)\u003c/strong\u003e 환경으로 가져오면 많은 개발자들이 헷갈려 하는 구간이 생깁니다.\u003c/p\u003e\n\u003cp\u003e바로 자바스크립트의 \u003cstrong\u003e\u0026lsquo;이름 변경\u0026rsquo;\u003c/strong\u003e 문법인 콜론(\u003ccode\u003e:\u003c/code\u003e)과 타입스크립트의 \u003cstrong\u003e\u0026lsquo;타입 지정\u0026rsquo;\u003c/strong\u003e 문법인 콜론(\u003ccode\u003e:\u003c/code\u003e)이 똑같이 생겼기 때문인데요.\u003c/p\u003e\n\u003cp\u003e오늘은 TypeScript 환경에서 에러 없이 객체의 구조 분해 할당, 이름 변경, 그리고 타입 지정까지 한 번에 처리하는 올바른 방법을 정리해 보겠습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"-흔히-하는-실수-문법의-충돌\"\u003e🚨 흔히 하는 실수: 문법의 충돌\u003c/h3\u003e\n\u003cp\u003eAPI 응답으로 스네이크 케이스(\u003ccode\u003euser_id\u003c/code\u003e) 데이터를 받아 카멜 케이스(\u003ccode\u003euserId\u003c/code\u003e)로 변환하면서, 동시에 \u003ccode\u003enumber\u003c/code\u003e라는 타입을 지정하고 싶다고 가정해 봅시다.\u003c/p\u003e","title":"[TypeScript] 구조 분해 할당 시 변수 이름 변경과 타입 지정 동시에 하는 방법"},{"content":"안녕하세요! TypeScript에서 구조 분해 할당(Destructuring) 을 사용할 때, JavaScript처럼 편하게 쓰려다가 빨간색 에러 줄을 마주친 경험이 한 번쯤은 있으실 겁니다.\n자바스크립트에서는 단순히 값을 꺼내오는 용도였지만, 타입스크립트에서는 \u0026lsquo;이 값을 꺼낼 건데, 이 값들의 타입은 이거야\u0026rsquo; 라고 컴파일러에게 명확히 알려주어야 합니다. 실무에서 가장 자주 쓰이는 객체, 배열, 그리고 함수 파라미터에서의 구조 분해 할당과 타입 지정 방법을 총정리해 드립니다.\n1. 객체(Object) 구조 분해 할당과 타입 지정 TypeScript에서 객체를 구조 분해 할당할 때 가장 많이 하는 실수는 \u0026lsquo;이름 변경\u0026rsquo; 문법(:)을 \u0026lsquo;타입 지정\u0026rsquo;으로 오해하는 것입니다.\n🚨 흔한 실수 (문법 오류) 1 2 3 4 const user = { name: \u0026#39;김개발\u0026#39;, age: 28 }; // 에러 발생! TS는 이를 \u0026#39;name을 string이라는 이름의 변수로 바꾸겠다\u0026#39;로 해석합니다. const { name: string, age: number } = user; ✅ 올바른 방법: 타입 분리하기 구조 분해 할당 괄호 {} 바깥에 전체 객체의 타입을 명시해야 합니다. 실무에서는 보통 interface나 type을 미리 선언하여 사용합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface User { name: string; age: number; } const user: User = { name: \u0026#39;김개발\u0026#39;, age: 28 }; // 1. 기본: 타입을 명시하고 구조 분해 할당 const { name, age }: User = user; // 2. 심화: 이름 변경과 타입 지정을 동시에 하기 // (name을 userName으로 변경) const { name: userName, age }: User = user; console.log(userName); // \u0026#39;김개발\u0026#39; (string 타입으로 추론됨) 2. 함수 파라미터(Parameter)에서의 구조 분해 할당 React 컴포넌트의 Props를 받거나, 여러 개의 인자를 가진 함수를 작성할 때 가장 많이 쓰이는 패턴입니다. 파라미터 자리에서 바로 구조 분해 할당을 하면서 타입을 지정할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 interface PrintOptions { title: string; isBold?: boolean; // 선택적 프로퍼티 } // 파라미터 자리에서 구조 분해 할당과 동시에 PrintOptions 타입 지정 function printText({ title, isBold = false }: PrintOptions) { console.log(`제목: ${title}, 굵게: ${isBold}`); } printText({ title: \u0026#39;타입스크립트 가이드\u0026#39; }); // 출력: 제목: 타입스크립트 가이드, 굵게: false 이 방식을 사용하면 함수 내부에서 props.title처럼 반복해서 적을 필요 없이 코드가 훨씬 간결해집니다.\n3. 배열(Array) 및 튜플(Tuple) 구조 분해 할당 배열은 객체와 달리 \u0026lsquo;순서(Index)\u0026lsquo;를 기준으로 값을 꺼내옵니다. TypeScript에서는 특히 길이가 고정된 배열인 튜플(Tuple) 을 구조 분해 할당할 때 그 진가를 발휘합니다.\n1 2 3 4 5 6 7 8 9 10 11 // 1. 일반 배열의 구조 분해 할당 const numbers: number[] = [1, 2, 3, 4, 5]; const [first, second, ...rest] = numbers; // first, second는 number, rest는 number[] 타입으로 추론됩니다. // 2. 튜플(Tuple)의 구조 분해 할당 (React useState와 동일한 원리) type Coordinates = [number, number, string]; const location: Coordinates = [37.5665, 126.9780, \u0026#39;Seoul\u0026#39;]; const [lat, lng, cityName] = location; // lat: number, lng: number, cityName: string 으로 정확히 타입이 매칭됩니다. 💡 요약: 이것만 기억하세요! 객체 할당 시: 내부의 콜론(:)은 이름 변경, 외부의 콜론(:)은 타입 지정입니다. 타입 선언 분리: 복잡한 타입은 가급적 인라인(Inline)으로 길게 적지 말고, interface나 type으로 빼서 선언하는 것이 가독성에 좋습니다. 함수 파라미터: 파라미터 내부에서 ({ a, b }: MyType) 형태로 구조 분해와 타입 지정을 동시에 할 수 있습니다. ","permalink":"https://qooing.github.io/posts/javascript/destructuring_typescript/","summary":"\u003cp\u003e안녕하세요! TypeScript에서 \u003cstrong\u003e구조 분해 할당(Destructuring)\u003c/strong\u003e 을 사용할 때, JavaScript처럼 편하게 쓰려다가 빨간색 에러 줄을 마주친 경험이 한 번쯤은 있으실 겁니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트에서는 단순히 값을 꺼내오는 용도였지만, 타입스크립트에서는 \u003cstrong\u003e\u0026lsquo;이 값을 꺼낼 건데, 이 값들의 타입은 이거야\u0026rsquo;\u003c/strong\u003e 라고 컴파일러에게 명확히 알려주어야 합니다. 실무에서 가장 자주 쓰이는 객체, 배열, 그리고 함수 파라미터에서의 구조 분해 할당과 타입 지정 방법을 총정리해 드립니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-객체object-구조-분해-할당과-타입-지정\"\u003e1. 객체(Object) 구조 분해 할당과 타입 지정\u003c/h3\u003e\n\u003cp\u003eTypeScript에서 객체를 구조 분해 할당할 때 가장 많이 하는 실수는 \u003cstrong\u003e\u0026lsquo;이름 변경\u0026rsquo; 문법(\u003ccode\u003e:\u003c/code\u003e)을 \u0026lsquo;타입 지정\u0026rsquo;으로 오해하는 것\u003c/strong\u003e입니다.\u003c/p\u003e","title":"[TypeScript] 구조 분해 할당(Destructuring) 완벽 정리: 올바른 타입 지정 방법"},{"content":"\n안녕하세요! 자바스크립트로 개발을 하다 보면 객체에서 필요한 값만 쏙쏙 뽑아 쓰는 구조 분해 할당(Destructuring Assignment) 을 숨 쉬듯이 사용하게 됩니다. 코드를 훨씬 간결하고 가독성 좋게 만들어주는 아주 고마운 문법이죠.\n하지만 가끔 객체의 키(Key) 이름 그대로 변수를 생성하고 싶지 않을 때가 있습니다. 변수 이름이 겹치거나, 서버에서 온 데이터의 키 이름이 마음에 들지 않을 때 말이죠. 오늘은 구조 분해 할당을 하면서 내가 원하는 이름으로 변수명을 변경하는 방법과 실무에서 자주 쓰이는 활용 사례를 정리해 보겠습니다.\n1. 기본 문법: 기존 이름 : 새로운 이름 구조 분해 할당에서 이름을 바꾸는 방법은 아주 간단합니다. 객체의 원래 속성 이름 뒤에 콜론(:)을 붙이고, 새로 사용할 변수 이름을 적어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 const user = { name: \u0026#39;김개발\u0026#39;, age: 28 }; // name을 userName으로, age를 userAge로 변경하여 할당 const { name: userName, age: userAge } = user; console.log(userName); // \u0026#39;김개발\u0026#39; console.log(userAge); // 28 // console.log(name); // ReferenceError: name is not defined 위 코드에서 보시다시피, name이나 age라는 변수는 생성되지 않으며 오직 userName과 userAge라는 새로운 이름의 변수만 사용할 수 있습니다.\n2. 실무에서는 언제 유용할까? 💡 상황 A. 변수명 충돌을 방지해야 할 때 이미 같은 스코프 내에 객체의 키와 동일한 이름의 변수가 선언되어 있다면, 구조 분해 할당 시 에러가 발생합니다. 이럴 때 이름을 변경해주면 충돌을 우려 없이 값을 추출할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 const title = \u0026#39;메인 페이지\u0026#39;; const article = { title: \u0026#39;구조 분해 할당 완벽 가이드\u0026#39;, content: \u0026#39;...\u0026#39; }; // 이미 title이라는 변수가 있으므로, articleTitle로 이름을 변경해서 추출 const { title: articleTitle } = article; console.log(title); // \u0026#39;메인 페이지\u0026#39; console.log(articleTitle); // \u0026#39;구조 분해 할당 완벽 가이드\u0026#39; 💡 상황 B. API 응답 데이터의 네이밍 컨벤션을 맞출 때 프론트엔드에서는 주로 카멜 케이스(camelCase) 를 사용하지만, 백엔드 API 응답은 종종 스네이크 케이스(snake_case) 로 오는 경우가 많습니다. 데이터를 받을 때 바로 구조 분해 할당으로 이름을 변경해주면 코드의 일관성을 유지하기 좋습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const apiResponse = { user_id: 101, first_name: \u0026#39;철수\u0026#39;, last_name: \u0026#39;김\u0026#39; }; // 스네이크 케이스를 카멜 케이스로 변경 const { user_id: userId, first_name: firstName, last_name: lastName } = apiResponse; console.log(userId, firstName, lastName); // 101 \u0026#39;철수\u0026#39; \u0026#39;김\u0026#39; 3. 심화: 이름 변경과 동시에 \u0026lsquo;기본값\u0026rsquo; 설정하기 구조 분해 할당의 또 다른 강력한 기능인 기본값 할당(Default values) 과 이름 변경을 동시에 사용할 수도 있습니다. 문법은 기존 이름 : 새로운 이름 = 기본값 형태가 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const settings = { theme: \u0026#39;dark\u0026#39;, // language 키는 없는 상태 }; // theme은 currentTheme으로 이름 변경 // language는 currentLang으로 이름 변경하되, 값이 없으므로 \u0026#39;ko\u0026#39;를 기본값으로 설정 const { theme: currentTheme, language: currentLang = \u0026#39;ko\u0026#39; } = settings; console.log(currentTheme); // \u0026#39;dark\u0026#39; console.log(currentLang); // \u0026#39;ko\u0026#39; 마치며 객체의 구조 분해 할당 시 변수 이름을 변경하는 원래키: 새변수명 문법은 간단하지만, 코드의 가독성을 높이고 변수명 충돌을 우아하게 해결해 주는 훌륭한 패턴입니다. 특히 외부 데이터를 다룰 때 네이밍 컨벤션을 맞추는 용도로 꼭 활용해 보시길 추천드립니다!\n","permalink":"https://qooing.github.io/posts/javascript/destructuring_name_change/","summary":"\u003cp\u003e\u003cimg alt=\"구조분해할당-Destructuring 이름 변경\" loading=\"lazy\" src=\"/images/javascript/destructuring_renaming.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요! 자바스크립트로 개발을 하다 보면 객체에서 필요한 값만 쏙쏙 뽑아 쓰는 \u003cstrong\u003e구조 분해 할당(Destructuring Assignment)\u003c/strong\u003e 을 숨 쉬듯이 사용하게 됩니다. 코드를 훨씬 간결하고 가독성 좋게 만들어주는 아주 고마운 문법이죠.\u003c/p\u003e\n\u003cp\u003e하지만 가끔 객체의 키(Key) 이름 그대로 변수를 생성하고 싶지 않을 때가 있습니다. 변수 이름이 겹치거나, 서버에서 온 데이터의 키 이름이 마음에 들지 않을 때 말이죠. 오늘은 구조 분해 할당을 하면서 \u003cstrong\u003e내가 원하는 이름으로 변수명을 변경하는 방법\u003c/strong\u003e과 실무에서 자주 쓰이는 활용 사례를 정리해 보겠습니다.\u003c/p\u003e","title":"[JavaScript/ES6] 구조 분해 할당(Destructuring) 시 변수 이름 변경하는 방법"},{"content":"\n자바스크립트로 개발을 하다 보면 객체나 배열 안에 있는 데이터를 꺼내서 변수에 담아야 할 일이 정말 많습니다. ES6(ECMAScript 2015) 이전에는 데이터를 하나하나 꺼내느라 코드가 길어지고 복잡해지기 일쑤였죠.\n하지만 구조 분해 할당을 사용하면 이 과정을 놀라울 정도로 단순하고 직관적으로 바꿀 수 있습니다. 오늘은 자바스크립트 개발자라면 반드시 알아야 할 구조 분해 할당에 대해 알아보겠습니다.\n1. 구조 분해 할당이란? 구조 분해 할당(Destructuring Assignment)은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 표현식입니다. 말 그대로 자료의 구조를 \u0026lsquo;분해\u0026rsquo;해서 변수에 \u0026lsquo;할당\u0026rsquo;한다는 의미입니다.\n2. 배열 구조 분해 (Array Destructuring) 배열은 데이터의 순서(Index) 가 중요합니다. 변수를 선언하고 배열의 순서대로 매칭해주면 됩니다.\n2-1. 기본 사용법 1 2 3 4 5 6 7 8 9 10 11 const fruits = [\u0026#39;사과\u0026#39;, \u0026#39;바나나\u0026#39;, \u0026#39;포도\u0026#39;]; // ES5 (기존 방식) const apple = fruits[0]; const banana = fruits[1]; // ✨ ES6 구조 분해 할당 const [apple, banana, grape] = fruits; console.log(apple); // \u0026#39;사과\u0026#39; console.log(banana); // \u0026#39;바나나\u0026#39; 2-2. 일부 요소 건너뛰기 쉼표(,)를 이용하면 필요하지 않은 요소는 건너뛰고 변수에 할당할 수 있습니다.\n1 2 3 4 5 const numbers = [1, 2, 3, 4]; const [one, , three] = numbers; // 두 번째 요소(2)는 건너뜀 console.log(one); // 1 console.log(three); // 3 2-3. 기본값 설정 (Default Values) 배열에 해당 값이 없을 경우를 대비해 기본값을 설정할 수 있습니다.\n1 2 3 4 5 const [a, b, c = 3] = [1, 2]; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 (배열에 값이 없어서 기본값 할당) 3. 객체 구조 분해 (Object Destructuring) 객체는 순서가 아니라 키(Key) 이름이 중요합니다. 추출하고 싶은 프로퍼티의 이름과 변수 이름을 똑같이 맞춰주면 됩니다.\n3-1. 기본 사용법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const user = { name: \u0026#39;김개발\u0026#39;, age: 28, job: \u0026#39;Frontend Developer\u0026#39; }; // ES5 (기존 방식) const name = user.name; const age = user.age; // ✨ ES6 구조 분해 할당 const { name, age, job } = user; console.log(name); // \u0026#39;김개발\u0026#39; console.log(job); // \u0026#39;Frontend Developer\u0026#39; 3-2. 변수 이름 바꾸기 (Renaming) 객체의 키 이름과 다른 이름으로 변수를 만들고 싶다면 콜론(:)을 사용합니다.\n1 2 3 4 5 const { name: userName, age: userAge } = user; console.log(userName); // \u0026#39;김개발\u0026#39; console.log(userAge); // 28 // console.log(name); // ReferenceError (name 변수는 선언되지 않음) 3-3. 중첩된 객체 꺼내기 객체 안에 또 객체가 있는 경우에도 한 번에 꺼낼 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 const profile = { title: \u0026#39;Profile\u0026#39;, data: { username: \u0026#39;dev_king\u0026#39;, email: \u0026#39;dev@test.com\u0026#39; } }; const { data: { username, email } } = profile; console.log(username); // \u0026#39;dev_king\u0026#39; 4. 실전 활용 꿀팁 (Best Practices) 구조 분해 할당이 가장 빛을 발하는 순간은 바로 함수의 파라미터를 다룰 때와 변수 교환을 할 때입니다.\n4-1. 함수 파라미터 간소화 함수에 객체를 전달할 때, 필요한 속성만 쏙쏙 뽑아서 사용할 수 있어 가독성이 매우 좋아집니다. (리액트의 Props 처리에 자주 쓰입니다!)\n1 2 3 4 5 6 7 8 9 10 11 12 // 기존 방식 function printUser(user) { console.log(user.name + \u0026#39;님은 \u0026#39; + user.age + \u0026#39;살입니다.\u0026#39;); } // ✨ 구조 분해 할당 적용 function printUser({ name, age }) { console.log(`${name}님은 ${age}살입니다.`); } const user = { name: \u0026#39;이코딩\u0026#39;, age: 30 }; printUser(user); 4-2. 두 변수의 값 교환 (Swap) 임시 변수(temp) 없이 두 변수의 값을 아주 우아하게 바꿀 수 있습니다.\n1 2 3 4 5 6 7 let x = 10; let y = 20; [x, y] = [y, x]; console.log(x); // 20 console.log(y); // 10 💡 마치며 구조 분해 할당은 처음 접하면 낯설 수 있지만, 익숙해지면 코드의 양을 줄여주고 가독성을 높여주는 최고의 도구가 됩니다. props를 다루거나 API 응답 데이터를 처리할 때 적극적으로 활용해 보세요!\n","permalink":"https://qooing.github.io/posts/javascript/destructuring/","summary":"\u003cp\u003e\u003cimg alt=\"구조분해할당-Destructuring\" loading=\"lazy\" src=\"/images/javascript/destructuring.png\"\u003e\u003c/p\u003e\n\u003cp\u003e자바스크립트로 개발을 하다 보면 객체나 배열 안에 있는 데이터를 꺼내서 변수에 담아야 할 일이 정말 많습니다. ES6(ECMAScript 2015) 이전에는 데이터를 하나하나 꺼내느라 코드가 길어지고 복잡해지기 일쑤였죠.\u003c/p\u003e\n\u003cp\u003e하지만 \u003cstrong\u003e구조 분해 할당\u003c/strong\u003e을 사용하면 이 과정을 놀라울 정도로 단순하고 직관적으로 바꿀 수 있습니다. 오늘은 자바스크립트 개발자라면 반드시 알아야 할 구조 분해 할당에 대해 알아보겠습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-구조-분해-할당이란\"\u003e1. 구조 분해 할당이란?\u003c/h3\u003e\n\u003cp\u003e구조 분해 할당(Destructuring Assignment)은 배열이나 객체의 속성을 해체하여 그 값을 \u003cstrong\u003e개별 변수에 담을 수 있게 하는 표현식\u003c/strong\u003e입니다. 말 그대로 자료의 구조를 \u0026lsquo;분해\u0026rsquo;해서 변수에 \u0026lsquo;할당\u0026rsquo;한다는 의미입니다.\u003c/p\u003e","title":"[JavaScript/ES6] 코드를 깔끔하게! 구조 분해 할당(Destructuring Assignment) 완벽 정리"}]